import 'package:fixnum/fixnum.dart';

import 'utils.dart';

/// A Hash visualization class from a provided hash as blocks of pixels.
class Hashviz {
  String hashToVisualize;
  int visualizationSize;
  final bool isSymmetric;
  final int numColors;
  List<int> _randomSeed = [];

  /// Create a visualization hash class.
  ///
  /// Depending on provided [hashToVisualize] and [visualizationSize] a
  /// visualization blocks will be generated. [hashToVisualize] is the string
  /// to be represented as visualization blocks. [visualizationSize]
  /// represents the blocks size in the visualization, if it is negative only
  /// the absolute value will be considered.
  Hashviz({
    required this.hashToVisualize,
    int visualizationSize = 10,
    this.isSymmetric = false,
    int numColors = 3,
  })  : visualizationSize = isPositive(visualizationSize) ? visualizationSize : 1,
        numColors =
            isPositive(numColors) ? _clampedNumColors(visualizationSize, numColors) : 3;

  /// A 2D-array of visualization blocks (image data).
  ///
  /// The visualization blocks (image data) is generated by creating pixels
  /// based on the [Hashviz.hashToVisualize] string. Returns a List of
  /// integers representing the visualization blocks (image data).
  List<int> get visualizationBlocks {
    _randomSeed = _createRandomSeed(hashToVisualize);

    return _createVisualizationBlocks(visualizationSize, isSymmetric, numColors);
  }

  /// Creates image data.
  ///
  /// The array generated represents the pattern to be drawn. A value of 1 or
  /// 2 means a block should be drawn, while 0 indicates the background.
  ///
  /// For now, only a square images are supported.

  List<int> _createVisualizationBlocks(int visualizationSize, bool isSymmetric, int numColors) {
    final width = visualizationSize;
    final height = visualizationSize;

    final effectiveNumColors = numColors.clamp(2, 9);

    var data = <int>[];
    for (var y = 0; y < height; y++) {
      var row = <int>[];

      final halfWidth = isSymmetric ? (width / 2).ceil() : width;

      for (var x = 0; x < halfWidth; x++) {
        // numColors controls the possible values.
        // `rand()` generates a decimal value, we multiply it by `effectiveNumColors`.
        // `floor()` round down to the nearest integer. This ensures that the final value is in the range 0 to numColors - 1.
        // The value 0 will correspond to the background.
        row.add(
            (_generateRandomFloatFromSeed() * (effectiveNumColors)).floor());
      }

      if (isSymmetric) {
        final reflected = List<int>.from(row.reversed);
        row.addAll(reflected);
      }

      data.addAll(row);
    }

    return data;
  }

  /// Limits the number of colors based on the size of the blocks
  static int _clampedNumColors(int size, int numColors) {
    final maxColors = size * size;
    return numColors > maxColors ? maxColors : numColors;
  }

  /// Create random seed from the [seed]
  ///
  /// The [seed] is used to generate consistent patterns.
  List<int> _createRandomSeed(String seed) {
    var randomSeed = List<int>.filled(4, 0);

    for (int i = 0; i < seed.length; i++) {
      randomSeed[i % 4] =
          (randomSeed[i % 4] << 5) - randomSeed[i % 4] + seed.codeUnitAt(i);
    }

    return randomSeed;
  }

  /// Generates a random value based on the seed
  double _generateRandomFloatFromSeed() {
    // based on Java's String.hashCode(), expanded to 4 32bit values
    final t = Int32(_randomSeed[0] ^ Int32(_randomSeed[0] << 11).toInt());
    final third = Int32(_randomSeed[3]);

    _randomSeed[0] = _randomSeed[1];
    _randomSeed[1] = _randomSeed[2];
    _randomSeed[2] = _randomSeed[3];
    _randomSeed[3] = ((third ^ (third >> 19)) ^ t ^ (t >> 8)).toInt();

    return (Int32(_randomSeed[3] >>> 0)).toInt() / ((1 << 31) >>> 0);
  }
}
