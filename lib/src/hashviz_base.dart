import 'package:fixnum/fixnum.dart';

class Hashviz {
  final int _size;
  final bool _isSymmetric;
  final int _numColors;
  List<int> _randSeed = [];

  /// Constructor for the [Hashviz] class.
  ///
  /// - Parameters:
  ///   - [size]: The size of the blocks in the visualization. Must be a positive integer.
  ///   - [isSymmetric]: A boolean indicating if the visualization should be symmetric.
  ///   - [numColors]: An int indicating if the number of colors to be represented.
  ///
  /// - Throws:
  ///   - [ArgumentError] if the size is not a positive integer.
  Hashviz({
    required int size,
    required bool isSymmetric,
    required int numColors,
  })  : _size = _isPositive(size)
            ? size
            : throw ArgumentError("size must be a positive integer."),
        _isSymmetric = isSymmetric,
        _numColors = _isPositive(numColors)
            ? _clampedNumColors(size, numColors)
            : throw ArgumentError("numColors must be a positive integer.");

  /// Method to generate image data from a hash string
  ///
  /// The image data is generated by creating pixel data based on the hash.
  /// - Parameters:
  ///   - [hash]: A string used as the seed to generate the pattern.
  ///
  /// - Returns: A List of integers representing the image data.
  List<int> generatePatternData(String hash) {
    _randSeed = createRandSeed(hash);

    return createImageData(_size, _isSymmetric, _numColors);
  }

  /// Method to create a random seed from the hash
  ///
  /// The seed is used to generate consistent patterns based on the hash input.
  List<int> createRandSeed(String seed) {
    var randSeed = List<int>.filled(4, 0);

    for (int i = 0; i < seed.length; i++) {
      randSeed[i % 4] =
          (randSeed[i % 4] << 5) - randSeed[i % 4] + seed.codeUnitAt(i);
    }
    return randSeed;
  }

  /// Generates a random value based on the seed
  double rand() {
    // based on Java's String.hashCode(), expanded to 4 32bit values
    final t = Int32(_randSeed[0] ^ Int32(_randSeed[0] << 11).toInt());
    final third = Int32(_randSeed[3]);

    _randSeed[0] = _randSeed[1];
    _randSeed[1] = _randSeed[2];
    _randSeed[2] = _randSeed[3];
    _randSeed[3] = ((third ^ (third >> 19)) ^ t ^ (t >> 8)).toInt();

    return (Int32(_randSeed[3] >>> 0)).toInt() / ((1 << 31) >>> 0);
  }

  /// Creates image data, an array of blocks
  ///
  /// The array generated represents the blocky pattern to be drawn.
  /// A value of 1 or 2 means a block should be drawn, while 0 indicates the background.
  List<int> createImageData(int size, bool isSymmetric, int numColors) {
    final width = size; // Only support square icons for now
    final height = size;

    final effectiveNumColors = numColors.clamp(2, 9);

    var data = <int>[];
    for (var y = 0; y < height; y++) {
      var row = <int>[];

      final halfWidth = isSymmetric ? (width / 2).ceil() : width;

      for (var x = 0; x < halfWidth; x++) {
        // numColors controls the possible values.
        // `rand()` generates a decimal value, we multiply it by `effectiveNumColors`.
        // `floor()` round down to the nearest integer. This ensures that the final value is in the range 0 to numColors - 1.
        // The value 0 will correspond to the background.
        row.add((rand() * (effectiveNumColors)).floor());
      }

      if (isSymmetric) {
        final reflected = List<int>.from(row.reversed);
        row.addAll(reflected);
      }

      data.addAll(row);
    }

    return data;
  }

  static bool _isPositive(int value) {
    return value > 0;
  }

  /// Limits the number of colors based on the size of the blocks
  static int _clampedNumColors(int size, int numColors) {
    final maxColors = size * size;
    return numColors > maxColors ? maxColors : numColors;
  }
}
